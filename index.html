<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" />
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- I - le monolithe et les appli maison -->
        <section>I - L'architecture monolithique</section>
        <section>
          « Un monolithe est un bloc de grandes dimensions constitué d'un seul
          tenant. »
        </section>
        <section>
          <img
            src="./ressources/monolithe.png"
            alt="application monolithique"
          />
        </section>

        <!-- 
          définition
          ----------
          Une application monolithique et par extension une architecture monolithique est 
          une application dont l'ensemble du code et des fonctionnalités sont implémentés 
          dans un seul programme, au travers d'une seule base de données.

          commentaires
          ------------
          - l'ensemble des couches applicatives sont liées au travers d'une seule réalisation.
          - une base, le plus souvant relationnelle fédère l'ensemble de la donnée au travers d'un modèle métier unique.
          - un seul dépot de code.
          - dans sa version la plus hard, une seule instance de déploiment.
		    -->
        <section>Dans la pratique, une situation plus nuancée.</section>
        <!-- 
          - à l'institut, comme dans le reste du monde la situation dans la pratique est plus nuancée. Le parc de l'institut est doté d'application plus complexe.
        -->
        <section>
          <p>Les petites application « React »</p>
          <img
            src="./ressources/appli-react.png"
            alt="une petite application React"
          />
        </section>
        <!-- 
          - depuis quelques années déjà, de nombreuses petites application.
          - séparation physique de la couche présentation. Cette isolation franche facilite l'évoluvilité du client de présentation, voir sa refonte intégrale (onyxia par ex).
          - le web-service conçu, s'il est conçu comme non couplé à l'ihm pourraut-être ouvert à d'autres usages, d'autres utilisateurs.
          - plus un monolithe au sens strict du terme.
          - toutefois toute la logique métier concentrée dans le même code et les mêmes données.
          - au fond, pour une petite appli, tant que les inter-action exterieures restent limitées, c'est bien suffisant.
          - toutefois, cette première expérience illustre déjà le bénéfice potentiel d'une architecture plus modulaire(même si ici on isole juste une couche)
        -->
        <section>
          <p>Des applications souvant plus complexes</p>
          <img src="./ressources/appli-insee.png" alt="application Insee" />
        </section>
        <!-- 
          - la logique métier souvant répartit derrière plusieurs sous-modules : le back, le front, l'appli de collecte, ....
          - toujours une seule base de données et un seul modèle.
          - dans la pratique ça reste un monolithe ou chaque composant est prévu pour servir un système conçu et modélisé comme un seul bloc.
          - refaire un composant reste lourd et risqué pour les autres modules.
        -->
        <section>
          <p>Les bénéfices de la simplicité</p>
          <ul>
            <li>conforme à notre formation et nos compétences</li>
            <li>plus simple à bien des égards</li>
            <li>moins couteux à court terme</li>
          </ul>
          <!--
            commentaires
            -----------
            - c'est ce que l'on sait faire et ce à quoi on nous prépare au travers des formations attachés et controleurs
            - plus simple à concevoir, à developper (code et version) et à deployer. pas besoin de service transverse (broker, gestion de containers, ...)
            - moins couteux : moins de fragmentation = moins de code = moins de travail, moins d'env, pas d'inv ou moins transversaux.
          -->
        </section>
        <section>
          <p>Oui mais, ...</p>
          <ul>
            <li>maintenance complexe</li>
            <li>obsolécense inévitable</li>
            <li>couteux à long terme</li>
          </ul>
        </section>
        <!--
          commentaires
          ------------
          - gros ensemble ensemble de code avec une forte intrication des fonctionnalités devient toujours plus difficile à maintenir au fil du temps (correction et évolution) avec le temps.
          - redéploiement en production complexe, parfois pour quelques lignes seulement.
          - socle technique verrouillé à la conception.
          - obsolécence d'une pièce entraine l'obsolécense de l'ensemble.
          - au final, une refonte tout les 5 ans = couteux à long terme.
        -->
        <!-- II - Principes et pattern -->
        <section>II - Quelques principes et patterns d'architecture</section>
        <section>Separation Of Concerne</section>
        <!-- 
          Principe de réalisation qui consiste à tracer des frontiéres pour isoler de grands ensembles fonctionnels selon des préoccupations métiers ou techniques spécifiques.
          - ce traduit en général par l'isolation d'élèment cohérent d'information du système.
          => principe applicable à plusieurs degrés : même pour un monolithe dans un seul dépôt le principe est envisageable.
        -->
        <section><img src="./ressources/3-tiers.png" alt="3 tiers" /></section>
        <!--
          Le 3 tiers est une séparation technique des couches applicatives, largement appliquée.
        -->
        <section><img src="./ressources/n-tiers.png" alt="3 tiers" /></section>
        <!-- 
          Séparation métier
          - isolation des logiques distinctes selon les spécificités propre à chaque acteur.
           isolation peut se formaliser :
              . au niveau du code par des règles de nommage de classes/packages, des modules autonomes (Séparation logique).
              . au niveau de l'architecture par des services isolées encapsulant données et fonctionnalités(Séparation physique).

        -->
        <section>Single Responsability Principle</section>
        <!-- 
          Principe de réalisation selon lequel chaque module, classe ou fonction ne doit être porteur que d'une seule fonctionnalité et l'encapsule.
          Dit plus vulgairement un module, une classe ou une fonction ne fait " qu'une chose " 
          - SOC peut-être perçu comme un ensemble cohérent de responsabilités. 
          - principe bien connu des dev Java : une classe n'a qu'une seule responsabilité.
          - Au fond, tout est affaire de sémantique : c'est le concepteur qui pose les mots définissant les responsabilités.
        -->
        <!-- 
          - SOC et SRP : ce sont 2 principes coutumiers pour tout développeur, appliqués au quotidien dans l'écriture de code.
          - séparation en module souvant effective à l'Insee, mais sans séparation physique (des données).
        -->
        <section>Command Query Response Segregation</section>
        <!-- 
          Le pattern CQRS (Command Query Responsibility Segregation) repose sur un principe simple : 
          la séparation, au sein d’une application, des composants de traitement métier de l’information (“command” / écriture) et de restitution de l’information (“query” / lecture).
          (extrait d'octo talk : https://blog.octo.com/cqrs-larchitecture-aux-deux-visages-partie-1/) 
          - Grosso modo : on sépare les opérations de lecture des opérations d'écriture.
          - Selon ce principe, la représentation de la donnée dans un système efficace n'est pas unique :
            - une vision métier pour COMMANDS : facilitant la lisibilité et la compréhension des opérations d'écriture, jugées souvent plus complexes.
            - une vision orienté présenation pour QUERIES : accélérant le processus de restitution de la données, en passant le modèle pour l'affichage
             (dénormalisation de la data pour éviter de grosse jointure, souvent croisé des vues matérialisées ou des tables dont c'est la vocation)
          - Pattern libre d'implémentation. : s'applique à des degrés différents :
            - une petite application peu se contenter de séparer les responsabilités d'écriture au sein de classe distinctes
            - un gros système pourra formaliser des services et des systèmes de stockage de données distincts. 
        -->
        <section><img src="./ressources/CQRS.png" alt="3 tiers" /></section>
        <section>Event Sourcing</section>
        <!-- III - L'architecture de microservices -->
        <section>III - L'architecture de microservices</section>
        <section>principe</section>
        <!-- 
          définition
          ----------
          Technique d'architecture/ de conception logiciel où le système est structuré en un ensemble indépendant de services, faiblement couplés les un les autres.
          - chaque service est conçu isolément comme une seule application.
          - un mode d'organisation innovant : un service = une team (squad produit : une équipe auto organisationnée dont les membres se sont choisis et décident de la construction du produit)
        -->
        <section>
          Un système hautement distribué
          <img
            src="./ressources/archi-microservices.png"
            alt="isolation des microservices"
          />
        </section>
        <section>
          Chez les GAFAM : vers un réseau non prédictible
          <img
            src="./ressources/netflix-microservices.png"
            alt="netflix microservices"
          />
        </section>
        <!--
          - on passe d'un seul système -> n applications faiblement couplées.
          - SAO poussé à l'extrème
        -->
        <section>
          <p>Un plus grand niveau d'isolation</p>
          <img
            src="./ressources/isolation-microservices.png"
            alt="isolation des microservices"
          />
        </section>
        <!--
          - isolation au mieux des responsabilités : portage de SRP à l'échelle de l'architecture.
          - isolation du code : jusqu'au runtime.
          - isolation des données :séparation physique et conceptuelle de la données.
        -->

        <section>L'enjeu majeur de la cohérence transactionnelle</section>
        <section>orchestration et chorégraphie</section>
        <section>Intérêt et limites</section>
        <!--
          ++
          - ne plus lier le destin de chacune des fonctionnalités d'un système.
          -
          --
          - compléxité transactionnelle, rupture radicale de l'approche de la données pour nous.
         -->
        <section>IV - Quelques mots sur le micro front-end</section>
        <!-- 
          - pour beaucoup d'entreprise, l'interface client constitue l'enjeu majeur du SI (facebook, amazone, twitter ...) -> une trés, trés grosse application.
          |=> besoin de structuration|d'isolation des fonctionnalités.
          Un macro service aiguille les requête vers n sous service selon le besoin concrêt de l'utilisateur. Derrière le système est libre de choisir son modèle d'architecture.
          - elle aggrège des logiques métiers distinctes : logique commerciale, logistique, SAV ...
          - appliquer les principes de division pour éviter de concevoir une seule grosse application qui résoud toutes ces logiques.
          - une architecture de microservice n'est pas obligatoire : un seul système d'info et n service peut tout à faire suffire.
        -->

        <!-- SYNTHESE-->
        <!-- 
          - Pas besoin d'être Nexflix pour faire du micro service : quelques services (micro ou pas) c'est déjà bien.
          - Une séparation physique, pas pour tout le monde : inutile de couper des grain de riz en 2.
          - toutefois, même petit on peut quand même intégrer SOC et SRP dans le code.
          - quelques mot sur les API et WS ?
        -->
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      Reveal.initialize({
        hash: true,
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
